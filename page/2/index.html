<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Promise" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/Promise/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T09:00:19.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/Promise/">Promise</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>promise是异步编程的一种解决方案，返回值是promise对象的都是异步函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&quot;https://...&quot;).then((response)=&gt;reponse.json()).catch((error)=&gt;console.log(error))</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">if(/*异步操作成功*/)&#123;</span><br><span class="line">resolve(value)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">reject(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise的三种状态</p>
<p>待定（pending）：初始状态，没有被兑现，也没有被拒绝</p>
<p>已兑现（fufilled）：意味着操作成功</p>
<p>已拒绝（rejected）：意味着操作失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const promise =new Promise((resolve,reject)=&gt;&#123;&#125;)</span><br><span class="line">console.log(promise)//pending</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;resolve(&#x27;hello world&#x27;)&#125;).then(val=&gt;console.log(val))//resolve可以改变promise的状态，并且可以通过.then来拿到改变以后的结果</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;reject(&#x27;bad code&#x27;)&#125;).then(err=&gt;console.log(err))//状态时rejected，返回的结果bad code</span><br></pre></td></tr></table></figure>

<p>要想拿到使用reject改变以后的promise里面的值，除了使用.then方法以外同时可以使用catch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ew Promise((resolve,reject)=&gt;&#123;reject(&#x27;bad code&#x27;)&#125;).catch(fucntion(err)=&gt;console.log(err))</span><br></pre></td></tr></table></figure>

<p>除了.catch.then还有.finally方法，只有再promise状态被改变了以后才会触发finally函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;reject(&#x27;bad code&#x27;)&#125;).then(err=&gt;console.log(err).finally(()=&gt;console.log(&#x27;promise状态变更&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<p>把嵌套的回调函数改为链式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function counter(x,y,wait)</span><br><span class="line">&#123;</span><br><span class="line">return new Promise(function(resolve,reject)&#123;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">resolve(x+y)</span><br><span class="line">&#125;,wait)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">counter(1,2,1000).then(val=&gt;counter(val,1,1000)).then(num=&gt;console.log(num))</span><br></pre></td></tr></table></figure>

<p><strong>Promise的方法</strong></p>
<p>Promise.resolve(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(2).then(2)((val)=&gt;&#123;</span><br><span class="line">console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回的是一个状态为fulfilled的Promise对象并且有一个返回值为2</p>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">resolve(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.reject(n)方法返回一个带有拒绝原因的Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&#123;message:&quot;错误原因&quot;&#125;).catch((err)=&gt;console.log(err))</span><br></pre></td></tr></table></figure>

<p>Promise.all()方法接受一个promise的iterable类型，（Array，Map，Set都属于ES6的iterable类型），返回一个promise实例</p>
<p>只有再所有的promise状态都发生了变化以后才会拿到结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise1=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">const promise2=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">const promise3=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">const promise4=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">Promise.all(promise1,promise2,promise3,promise4).then((val)=&gt;console.log(val))</span><br><span class="line">---</span><br><span class="line">两秒以后输出</span><br><span class="line">123 123 123 123</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/Promise/" data-id="cl4o61a1o0001vkfo8bsfen5c" data-title="Promise" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-箭头函数和方法扩展" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T07:09:54.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/">箭头函数和方法扩展</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>传统函数声明</p>
<p>声明式：function fn(){}</p>
<p>表达式： var fn &#x3D; function(){}</p>
<p>箭头函数</p>
<p>var fn &#x3D; ()&#x3D;&gt;{}</p>
<p>如果参数只有一个参数只有一个可以省略（）</p>
<p>如果函数体只有一句return加表达式的话{}和return可以省略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn = v =&gt; v+1</span><br></pre></td></tr></table></figure>

<p>如果返回值并不是表达式的话可以使用（）来包裹起来同时可以省略return</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn  = v =&gt;(&#123;obj:v&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>箭头函数与普通函数的区别</strong></p>
<ol>
<li><p>箭头函数是没有this的，它的this是从作用域链上一层继承来的，同时也无法通过call和apply来改变this的指向</p>
</li>
<li><p>不能作为构造函数，没有protorypep属性</p>
</li>
<li><p>没有arguments对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3)</span><br><span class="line">---</span><br><span class="line">Arguments(3)&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">var foo = () =&gt;&#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3)</span><br><span class="line">---</span><br><span class="line">报错</span><br></pre></td></tr></table></figure>

<p>想要获取箭头函数的参数列表可以使用…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = (...arguments) =&gt;&#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3)</span><br><span class="line">---</span><br><span class="line">(3)&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>不能使用yield命令，所以箭头函数不能作为Generator函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//generator函数</span><br><span class="line">function *fn()&#123;</span><br><span class="line">yield 1;</span><br><span class="line">yield 2;</span><br><span class="line">return 3</span><br><span class="line">&#125;</span><br><span class="line">var f = fn()</span><br><span class="line">console.log(f)</span><br><span class="line">console.log(f.next())</span><br><span class="line">console.log(f.next())</span><br><span class="line">console.log(f.next())</span><br><span class="line">console.log(f.next())</span><br><span class="line">---</span><br><span class="line">fn&#123;...&#125;</span><br><span class="line">&#123;value:1,done:false&#125;</span><br><span class="line">&#123;value:2,done:false&#125;</span><br><span class="line">&#123;value:3,done:true&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>实际应用</strong></p>
<p>在函数内部想要拿到外部实例的时候可以使用箭头函数，这样函数体中的this就直接指向了外部实例</p>
<p>setTimeout，setInterval</p>
<p><strong>函数扩展方法</strong></p>
<ol>
<li><p>给函数的参数指定默认值，es5</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn (x,y)&#123;</span><br><span class="line">//如果y存在，那么就取y，如果y不存在，那么就y=1</span><br><span class="line">y = y||1</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn (x,y=1)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn (&#123;x,y=1&#125;)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;X:1&#125;)</span><br><span class="line">//先解构，然后再赋一个默认值</span><br></pre></td></tr></table></figure>


</li>
<li><p>通过rest参数获取函数的多余参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn (x,...y)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,3,4)</span><br><span class="line">---</span><br><span class="line">1</span><br><span class="line">2,3,4</span><br></pre></td></tr></table></figure>

<p>…y称为rest参数，是所有未被定义的实参的参数数组集合，也一样可以解构赋值。如果参数是对象的话那么就是所有未被定义的属性所形成的一个新的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn(&#123;x,...y&#125;)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;x:1,a:2,b:3&#125;)</span><br><span class="line">---</span><br><span class="line">1</span><br><span class="line">&#123;a:2,b:3&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/" data-id="cl4o61a1s0004vkfo1pdz6779" data-title="箭头函数和方法扩展" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Iterator和for-of循环" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T06:18:05.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/">Iterator和for...of循环</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Iterator概念</p>
<p>Iterator接口的目的就是为所有的数据结构提供一种统一的访问机制，即for of循环从而完成遍历的操作。当使用for…of循环时，该循环会自动调用Iterator的接口。</p>
<p>for…of循环的遍历过程</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置，因而遍历器本质上就是一个指针对象</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的next方法，可以将指针指向数据结构的第二个成员</li>
<li>不断调用指针对象，直到它指向数据结构的最后结束位置</li>
</ol>
<p>每一次调用next方法返回一个包含value和done两个属性的对象</p>
<p>其中value是当前成员的值，done属性是一个布尔值，表示遍历是否结束</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>(arr)</span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">//value:&#x27;1&#x27;,done:false</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">//value:&#x27;2&#x27;,done:false</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">//value:undefined,done:true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> nextIndex&lt;arr.<span class="property">length</span>?&#123;</span><br><span class="line">         <span class="attr">value</span>:arr[nextIndex++],<span class="attr">done</span>:<span class="literal">false</span></span><br><span class="line">     &#125;:&#123;</span><br><span class="line">         <span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Iterator接口时部署在Symbol.iterator属性</strong></p>
<p>如果一个数据结构具有Symbol.iterator属性，那么这个数据结构就是可便利的。</p>
<p>Symbol.iterator属性本身是一种函数，就是当前数据结构的遍历器默认生成的一个函数，执行这个函数就会放回一个遍历器对象，（该对象的根本特征就是会具有next方法，每一次调用next()，都会返回一个代表当i请安成员的信息对象,这个对象具有value和done两个属性）</p>
<p>对象的Symbol.iterator属性指向了该对象的默认遍历器方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">[Symbol.iterator] : function()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">next:function()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">value:1,</span><br><span class="line">done:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果要使用特殊的属性名，不能采用 . 的方式来操作</em></p>
<p><em>需要使用另一种方式：语法：对象[“属性名”] &#x3D; 属性值</em></p>
<p><em>读取时也需要采用这种方式</em></p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">[Symbol.iterator] : function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var it = arr[Symbol.iterator]()</span><br></pre></td></tr></table></figure>

<p><strong>原生具备iterator接口的数据结构</strong></p>
<p>Map,Set,Array,String,函数的arguments对象(伪数组)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;1&#x27;,&#x27;2&#x27;]</span><br><span class="line">var it = arr[Symbol.iterator]()</span><br><span class="line">it.next()</span><br><span class="line">//value:&#x27;1&#x27;,done:false</span><br><span class="line">it.next()</span><br><span class="line">//value:&#x27;2&#x27;,done:false</span><br><span class="line">it.next()</span><br><span class="line">//value:undefined,done:true</span><br></pre></td></tr></table></figure>

<p>对于原生部署了iterator的数据结构来说可以直接使用forof循环,但是如果没有iterator的接口的话(主要是数组),那么就要自己在[Symbol.iterator]上部署接口,这样才会被for…of循环</p>
<p>对象不具备iterator接口的原因是对象哪一个属性先遍历,哪一个属性后遍历时不确定的,需要开发者手动部署</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">data</span>:[<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>],</span><br><span class="line">[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">next</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;self.<span class="property">data</span>.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;&#123;<span class="attr">value</span>:self.<span class="property">data</span>[index++],<span class="attr">done</span>:<span class="literal">false</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/" data-id="cl4o61a1l0000vkfog8u7c8tz" data-title="Iterator和for...of循环" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/Map/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T12:02:16.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/Map/">Map</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Map是新的应用类型的字符串，类似于对象，但是键的范围但不限于字符串，各种类型的值包括对象类型的值都可以当作键</p>
<p>Object提供了‘字符串—值’的对应</p>
<p>Map提供了‘值—值’的对应，是一种更加完美的键值对的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p:&#x27;hello world&#x27;&#125;</span><br><span class="line">m.set(o,&#x27;content&#x27;)</span><br><span class="line">m.get(o)//&quot;content&quot;</span><br><span class="line">m.has(o)//true</span><br><span class="line">m.delete(o)//true</span><br><span class="line">m.has(o)//false</span><br></pre></td></tr></table></figure>

<p><strong>证明Map()是引用数据类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">console.log(map instance Map)//true</span><br><span class="line">console.log(Object.prototype.toString.call(map))//[object Map]</span><br></pre></td></tr></table></figure>

<p><em>console.log(Object.prototype.toString.call(map))使用原型链顶端的toString()方法的原因是因为数组和对象对toString()的方法进行了改写</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">toString:function()&#123;</span><br><span class="line">return &#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.toString()</span><br><span class="line">//这样就会覆盖.toString方法从而导致问题</span><br></pre></td></tr></table></figure>

<p><strong>Map可以接受数组作为参数，在Map构造函数中接受的数组必须是一个个表示键值对的数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let m =new Map([ [&#123;&#x27;name&#x27;:&#x27;z3&#x27;&#125;,1],[age,18] ])</span><br></pre></td></tr></table></figure>

<p>Map的存储特点是把对象作为键名的时候传输的是地址，所以下列中的两个{x:1}虽然形式相同但是实际的值不同，（存储在堆内存中的不同位置）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map([</span><br><span class="line">&#123;x:1&#125;,&#x27;abc&#x27;</span><br><span class="line">])</span><br><span class="line">console.log(m.get(&#123;x:1&#125;))</span><br><span class="line">//undefined</span><br><span class="line">//这里存进去的&#123;x:1&#125;其实是这个对象在堆内存中的地址</span><br><span class="line">let obj = &#123;x:1&#125;</span><br><span class="line">let m = new Map([</span><br><span class="line">obj,&#x27;abc&#x27;</span><br><span class="line">])</span><br><span class="line">console.log(m.get(obj))</span><br><span class="line">//abc</span><br></pre></td></tr></table></figure>

<p>Map可以接受数组作为参数，在Map构造函数中接受的数组必须是一个个表示键值对的数组的本质</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let m =new Map([ [&#123;&#x27;name&#x27;:&#x27;z3&#x27;&#125;,1],[age,18] ])</span><br><span class="line">//内部机制</span><br><span class="line">items.forEach(</span><br><span class="line">//([key,value],index)=&gt;m.set(key,value)</span><br><span class="line">([key,value])=&gt;m.set(key,value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> <strong>Map自带的方法</strong></p>
<p>m.keys()</p>
<p>m.values()</p>
<p>m.entries()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map([[&#x27;a&#x27;,&#x27;b&#x27;],[&#x27;c&#x27;,&#x27;d&#x27;]])</span><br><span class="line">m.set(&#x27;e&#x27;,10)</span><br><span class="line">console.log(m.size)</span><br><span class="line">console.log(m.keys())//输出所有键</span><br><span class="line">console.log(m.values())//输出所有值</span><br><span class="line">console.log(m.entries())//输出所有对应关系</span><br><span class="line">---</span><br><span class="line">3</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;&#125;</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;d&#x27;, 10&#125;</span><br><span class="line">&#123;&#x27;a&#x27; =&gt; &#x27;b&#x27;, &#x27;c&#x27; =&gt; &#x27;d&#x27;, &#x27;e&#x27; =&gt; 10&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Map参数的扩展</strong></em></p>
<p><em>任何具有Iterator接口，且每一个成员都是一个双元素的数组的数据结构，都可以当作Map构造函数的参数，</em></p>
<p><em>所以set和map也都可以作为Map构造函数的初始值，只要是每一个成员都是一个双元素的数组。</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/Map/" data-id="cl4mp48je0000c0fo7x8yctqv" data-title="Map" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Set" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/Set/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T11:00:21.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/Set/">Set</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Set是新的引用类型的数据解构，类似于数组，但是每一个成员都是唯一的，没有重复的值</p>
<p>Set本身是一个构造函数，用来生成Set数据结构</p>
<p>Set函数可以接受一个数组作为参数，用于初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3,4,1])</span><br><span class="line">console.log(set)</span><br><span class="line">---</span><br><span class="line">Set(4)&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Set可以转化为数组</strong>（通过…或者Array.from()），原因是应为Set数据结构支持for of循环（内部部署了iterator接口）</p>
<p>可以快速实现数组去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3,4,1])</span><br><span class="line">Array.from(set)</span><br><span class="line">[...set]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Set数据内部判断值的机制</strong>所使用的算法类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），但是如果是多个NaN的话那么Set会返回一个NaN，因为在Set内部两个NaN是全等的，但是对于精确相等运算符来说两个NaN是不全等的。</p>
<p><strong>Set实例的属性和方法</strong></p>
<p>set.add(1)：添加元素</p>
<p>set.has(1)：判断是否有这个属性</p>
<p>set.delete(2)：删除</p>
<p>set.forEach()：Set结构的实例和数组一样也是拥有forEach的方法，对每一个成员执行某种操作，没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let set = [1,4,3]</span><br><span class="line">set.forEach((value，index)=&gt;console.log(index+&#x27;:&#x27;+value))</span><br><span class="line">---</span><br><span class="line">1:1</span><br><span class="line">4:4</span><br><span class="line">3:3</span><br></pre></td></tr></table></figure>

<p><em>对于set.forEach来说是没有索引这个概念的，所以</em>：左右都一样</p>
<p>Set可以实现数组之间的集合操作</p>
<p>并集：let set &#x3D; new Set([…a,…b])</p>
<p>交集：let set &#x3D; new Set([…a].filter(x&#x3D;&gt;b.has(x)))</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/Set/" data-id="cl4mp48jh0001c0fogjb78920" data-title="Set" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Symbol" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/Symbol/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T08:45:14.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/Symbol/">Symbol</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> Symbol是es6新增的一种基本数据类型，只要是用于保证每一个对象属性的名字都是独一无二的</p>
<p>symbol函数可以接受一个字符串作为参数，表示对symbol实例的描述，主要是为了在控制台输出，或者转化为字符串时，比较容易曲风。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1=Symbol(&#x27;1&#x27;)</span><br><span class="line">let s2=Symbol(&#x27;2&#x27;)</span><br><span class="line">s1</span><br><span class="line">s2</span><br></pre></td></tr></table></figure>

<p>Symbol参数是一个对象时，就会调用该对象的toString方法，将其转化为字符串，然后才生成一个Symbol值</p>
<p>Symbol函数的参数只是对当前Symbol值的描述，所以相同参数的Symbol函数的返回值是不一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;</span><br><span class="line">let b = &#123;b:1&#125;</span><br><span class="line">let s1=Symbol(a)</span><br><span class="line">let s2=Symbol(b)</span><br><span class="line">let o = &#123;&#125;</span><br><span class="line">o[s1]=1</span><br><span class="line">o[s2]=2</span><br><span class="line">//如果不使用symbol的话，那么obja和objb在转换成字符串以后都是相同的，所以属性值会覆盖，但是使用symbol了以后就不会</span><br></pre></td></tr></table></figure>

<p>对象的Symbol.iterator属性</p>
<p>这是指向对象的默认遍历器方法,对象进行for of循环时，会调用Symbol.iretator方法返回该对象的默认遍历器</p>
<p>Object.getOwnPropertySymbols方法</p>
<p>可以获得只当对象的所有Symbol属性名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;</span><br><span class="line">let b = &#123;b:1&#125;</span><br><span class="line">let s1=Symbol(a)</span><br><span class="line">let s2=Symbol(b)</span><br><span class="line">let o = &#123;&#125;</span><br><span class="line">o[s1]=1</span><br><span class="line">o[s2]=2</span><br><span class="line">const objectStmbol=Object.getOwnPropertySymbols(o)</span><br><span class="line">---</span><br><span class="line">Symbol(s1) Symbol(s2)</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<p>私有属性，用symbol定义的属性名是在外界访问不到的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let private = Symbol(&#x27;private&#x27;)</span><br><span class="line">var obj = &#123;</span><br><span class="line">[private]:&#x27;私有属性&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = 1</span><br><span class="line">const two = 2</span><br><span class="line">//使用symbol的话就可以支持一样的变量名</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/Symbol/" data-id="cl4mp48jj0002c0fohnt8go7x" data-title="Symbol" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-解构赋值" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T08:01:00.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/">解构赋值</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> <strong>数组解构赋值</strong></p>
<p>按照一定模式，对数组中提取值，对变量进行赋值，这被称为解构赋值</p>
<p>方便地将一组参数与变量名对应起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c]=[1,2,3]</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>

<p><strong>模式匹配</strong></p>
<p>只要等号两边地模式相同，左边地变量就会被赋予对应的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [foo,[[bar],baz]]=[1,[[2],3]]</span><br><span class="line">let [,,third]=[1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>对象的解构赋值</strong></p>
<p>允许使用自变量的语法将对象的属性赋给变量，可以取得继承的属性</p>
<p>变量名必须属性名相同才能取到正确的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;bar&#125; = &#123;bar:&#x27;123&#x27;,foo:&#x27;456&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>同时也可以使用 :变量名的写法进行重命名,这样真正被赋值的就是后者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123;bar:baz&#125; = &#123;bar:&#x27;123&#x27;,foo:&#x27;456&#x27;&#125;</span><br><span class="line">console.log(baz)</span><br><span class="line">---</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>对象的解构赋值可以和数组解构赋值一起使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">p:[&#x27;1&#x27;,&#123;</span><br><span class="line">y:&#x27;2&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br><span class="line">let &#123;p:[x,&#123;y&#125;]&#125;=obj</span><br></pre></td></tr></table></figure>

<p>对象的解构可以设置默认值,默认值生效的条件是对象的属性值严格等于undefined</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x=3&#125;=&#123;&#125;</span><br><span class="line">---</span><br><span class="line">x=3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x:y=3&#125;=&#123;x:5&#125;</span><br><span class="line">---</span><br><span class="line">y=5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x=3&#125;=&#123;x:undefined&#125;</span><br><span class="line">---</span><br><span class="line">x=3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x=3&#125;=&#123;x:null&#125;</span><br><span class="line">---</span><br><span class="line">x=null</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/" data-id="cl4mp48jl0004c0fo4ghydm7u" data-title="解构赋值" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-let-const-var暂时性死区" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/let-const-var%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T07:34:34.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/let-const-var%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/">let,const var暂时性死区</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>let，const声明的变量不会发生变量提升，但var声明的变量就可以，变量在声明前就可以使用，值为undefined，原因是因为预编译的时候就已经把变量存入变量对象中。</p>
<p><strong>暂时性死区</strong></p>
<p>在代码块内使用let命令声明变量之前，变量时不能被使用的，在语法上称为暂时性死区TDZ</p>
<p>let是不能被重复声明的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function(b)&#123;</span><br><span class="line">let b</span><br><span class="line">&#125;</span><br><span class="line">//报错</span><br></pre></td></tr></table></figure>



<p><strong>块级作用域</strong></p>
<p>允许块级作用域的任意嵌套，但是每一层都是一个单独的作用域，每一层中的数据不互通。</p>
<p>应用场景：</p>
<p>内层变量可能会覆盖外面的变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var date= new Date()</span><br><span class="line">function f()&#123;</span><br><span class="line">//var date</span><br><span class="line">console.log(date)</span><br><span class="line">if(true)&#123;</span><br><span class="line">var date=&#x27;1&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>循环内部的计数变量泄露为全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4]</span><br><span class="line">for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">console.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">console.log(i)</span><br><span class="line">---</span><br><span class="line">1 2 3 4 4</span><br></pre></td></tr></table></figure>



<p><strong>const特殊之处</strong></p>
<p>const一旦声明就不能被改变，并且必须要给一个初始值。</p>
<p>但如果const后面是一个引用数据类型，那么地址是在栈里面不能够改变，但是真正的数据是存放在堆里面的，也就可以改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj=&#123;&#125;</span><br><span class="line">obj.name=&#x27;123&#x27;</span><br></pre></td></tr></table></figure>



<p><em>for循环内部变量 i 和循环变量 i 不在同一个作用域中。</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/let-const-var%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/" data-id="cl4mp48jj0003c0fobzjv39im" data-title="let,const var暂时性死区" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-web性能优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/19/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2022-06-19T12:27:45.000Z" itemprop="datePublished">2022-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/19/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">web性能优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>web性能有哪些：</strong></p>
<p>用户对加载时间和运行时的直观体验</p>
<p>页面加载到可交互和可响应所消耗的时间，页面在交互的时候的流畅度。</p>
<p><strong>如何进行Web性能优化</strong></p>
<ol>
<li>了解性能指标</li>
<li>专业的工具可量化的评估出网站和应用的性能表现</li>
<li>从网站页面响应的声明周期，分析出造成较差性能表现的原因</li>
<li>进行技术改造，可行性分析等具体的优化实施</li>
<li>迭代优化</li>
</ol>
<p><strong>web性能报告</strong></p>
<p>Lighthouse插件分析web应用和web页面，生成评估页面。</p>
<p>五个打分维度：检测得分，性能指标，优化建议，诊断结果，已通过的性能</p>
<p>优化建议</p>
<ol>
<li>移除阻塞渲染的资源：js教本和css没有请求回来导致的白屏，一般解决方法是内嵌进入本地而非在网上请求</li>
<li>预链接所需要请求的源，提前建立与所需要访问的资源之间的网络连接，link rel&#x3D;”preconnect”,link rel &#x3D; “dns-prefetch”DNS预解析</li>
<li>降低服务端的响应时间，网络请求资源收到服务器内核，带宽，内存三个因素影响。</li>
<li>适当调整图片大小&#x3D;&gt;小图片可以转化base64位编码、大图片可以压缩到可以接受为止</li>
</ol>
<p><strong>诊断结果</strong></p>
<p>对静态资源使用高效的缓存策略</p>
<p>较少主线程的工作</p>
<p>减少HTTP的请求</p>
<p><strong>浏览器缓存策略</strong></p>
<p>强缓存</p>
<p>不会向服务器发送请求，直接从缓存读取资源，第二次请求就会快很多。</p>
<p>Expires和Cache-Control这两种HTTP Header实现</p>
<p>强缓存有两个状态：</p>
<p>from memory cache：不访问服务器，直接从内存中读取缓存，浏览器关闭以后，数据不存在，再次打开相同界面不会出现from memory cache</p>
<p>from disk cache：直接从硬盘中读取，关闭浏览器以后数据依然存在，此资源不会因为该页面的关闭而释放掉，下次打开相同界面依然是from disk cache</p>
<p>协商缓存</p>
<p>在强制缓存失效以后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识决定是否使用缓存</p>
<ul>
<li>协商缓存生效，返回304和not modified</li>
<li>协商缓存失效，返回200和请求结果</li>
</ul>
<p><strong>精炼js代码</strong></p>
<p>减少业务复杂度</p>
<p>算法优化</p>
<p>动态规划</p>
<p>适用情况</p>
<p>最优子结构</p>
<p>无后效性</p>
<p>子问题重叠</p>
<p><em>从浏览器地址栏输入URL之后到页面渲染出来整个过程发生了什么</em></p>
<p>从浏览器地址栏输入URL，服务器接受到请求并转到处理后台（对应接口），接口进行响应，前后台http响应，拿到数据时浏览器和服务器之间会有对应的缓存机制，浏览器接收到数据后渲染出页面，js引擎对脚本进行执行。</p>
<p>优化的点：</p>
<p>请求之前对前端进行优化。</p>
<p>发出请求后可以对后端做出优化</p>
<p>接受到数据以后可以对数据进行处理，如分页等，对图片资源的缓存和对代码的优化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/19/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" data-id="cl4lccg0k00009cfogqaf1owc" data-title="web性能优化" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-防抖节流函数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/19/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-19T11:52:25.000Z" itemprop="datePublished">2022-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/19/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/">防抖节流函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>防抖函数的概念：</p>
<p>函数防抖：就是指在触发事件后，在n秒内函数只能调用一次，如果触发事件后在n秒内又触发了事件，那么会重新计算函数延执行的时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func,wait</span>)&#123;</span><br><span class="line"><span class="comment">//timer是定时器</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">       <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">       &#125;</span><br><span class="line">    timer=<span class="built_in">setTimeout</span>(func,wait)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>节流：当持续触发事件时，保证在一定时间内只调用一次事件处理函数，假设用户一直触发这个函数，且每一次触发这个函数都小于既定值，函数节流会每隔这个时间调用一次。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span> (func,deplay)&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">func</span>()</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;,deplay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>var timer &#x3D; null</em></p>
<p><em>!timer&#x3D;&#x3D;&#x3D;true</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/19/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/" data-id="cl4lccg0n00019cfogv4yghkf" data-title="防抖节流函数" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/23/%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%E7%BB%91%E5%AE%9A/">表单控件绑定</a>
          </li>
        
          <li>
            <a href="/2022/06/23/mixin/">mixin</a>
          </li>
        
          <li>
            <a href="/2022/06/23/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8/">事件处理器</a>
          </li>
        
          <li>
            <a href="/2022/06/22/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/">模糊查询</a>
          </li>
        
          <li>
            <a href="/2022/06/22/%E6%95%B0%E7%BB%84%E6%A3%80%E6%B5%8B/">数组检测</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>