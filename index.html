<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-class" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/class/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T11:57:42.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/class/">class</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>class可以理解为语法糖，将js只能通过构造函数创建实例的方法进行了补充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">constructor(name,age)&#123;</span><br><span class="line">this.name=name</span><br><span class="line">this.age=age</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&#x27;z3&#x27;,18)</span><br></pre></td></tr></table></figure>

<p><strong>class的特性</strong></p>
<ol>
<li><p>class的数据类型是一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof(class A&#123;&#125;))</span><br></pre></td></tr></table></figure>


</li>
<li><p>class的原型的constructor指向class</p>
</li>
<li><p>通过new关键字创建的实例的constructor指向class，类似于原型链</p>
</li>
<li><p>class内部的方式实际上都是定义在类的prototype上</p>
</li>
<li><p>通过类创建的对象的本质是调用类的constructor，如果类没有定义constructor，那么会在使用的时候默认添加</p>
</li>
<li><p>class不能直接调用，需要使用new关键字，这是class虽然是函数，但是和函数不同的地方</p>
</li>
<li><p>class内部的方法指向的是实例，class内部是严格模式，没有调用者的话函数内部的this就是undefined，在严格模式下也是不存在变量提升的，使用箭头函数的话就可以让class内部的方法中的this指向class实例，但是同时class里面的属性就会跑到实例上而非prototype上。</p>
</li>
<li><p>getter和setter</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">constructor(name)&#123;</span><br><span class="line">this.name = name</span><br><span class="line">&#125;</span><br><span class="line">get=()=&gt;&#123;</span><br><span class="line">return this.name</span><br><span class="line">&#125;</span><br><span class="line">set=(Name)=&gt;&#123;</span><br><span class="line">this.name = Name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态设置属性名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let method = &#x27;test&#x27;</span><br><span class="line">class A&#123;</span><br><span class="line">[method]=()=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过在属性和方法前面添加关键字static，这些属性和方法就不会被实例继承，只能通过【类名.属性名&#x2F;方法名】的方式来获取,静态方法指向的是类而不是类的实例，同时静态方法是允许重复命名的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">static a = 1</span><br><span class="line">static fn()&#123;&#125;</span><br><span class="line">fn()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>class的继承</strong></p>
<p>class的继承使用过extends实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class F&#123;</span><br><span class="line">a=1</span><br><span class="line">fn()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class S extends F&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(new S())</span><br></pre></td></tr></table></figure>

<p>如果是属性，就会直接继承在当前的实例上。方法会保留在类的原型上。</p>
<p>如果子类写了constructor，那么就必须要调用super()方法，在super调用前子类是没有this的。否则会报错，如果不写constructor那么就会隐式地调用。</p>
<p>子类调用super会触发父类的constructor并将参数传递过去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class F&#123;</span><br><span class="line">constructor(sname)&#123;</span><br><span class="line">this.sname=sname</span><br><span class="line">&#125;</span><br><span class="line">a=1</span><br><span class="line">fn()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class S extends F&#123;</span><br><span class="line">constructor(name)&#123;</span><br><span class="line">super(name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new S(&#x27;z3&#x27;))</span><br><span class="line">S.prototype.__proto__===F.protorype</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/class/" data-id="cl4o61a1r0003vkfo8uan4xt2" data-title="class" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-async和await" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/async%E5%92%8Cawait/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T11:28:35.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/async%E5%92%8Cawait/">async和await</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>async可以让我们以一种更加简单的方式写出基于Promise的异步行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function p()&#123;</span><br><span class="line">return new Promise(resolve=&gt;&#123;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">resolve(&#x27;异步结果&#x27;)</span><br><span class="line">&#125;，1000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async function fn()&#123;</span><br><span class="line">const res = await p()</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async可以直接返回一个promise对象，状态是fufiled</p>
<p><strong>特性</strong></p>
<ol>
<li><p>async函数内部会返回一个promise对象，如果不是promise，那么它会隐式地包装在promise中（Promise.resolve(‘不是promise的值’)）</p>
</li>
<li><p>await能获取到promise状态改变后地值，如果后面不是一个promise，那么await会把该值转换为已正常处理的（PromisePromise.resolve(‘不是promise的值’).then(()&#x3D;&gt;undefined）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">await 1</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">//返回的结果是状态为fufiled，内容为undefined的promise对象</span><br></pre></td></tr></table></figure>


</li>
<li><p>await后面的promise状态是reject，那么await后的代码不会被执行，async函数将返回状态为reject的promise</p>
</li>
<li><p>async函数内部如果存在await，那么await表达式会暂停整个async函数的执行，等当前promise状态改变后才能恢复</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/async%E5%92%8Cawait/" data-id="cl4o61a1q0002vkfo5c5d5pas" data-title="async和await" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Promise" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/Promise/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T09:00:19.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/Promise/">Promise</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>promise是异步编程的一种解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">if(/*异步操作成功*/)&#123;</span><br><span class="line">resolve(value)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">reject(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise的三种状态</p>
<p>待定（pending）：初始状态，没有被兑现，也没有被拒绝</p>
<p>已兑现（fufilled）：意味着操作成功</p>
<p>已拒绝（rejected）：意味着操作失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const promise =new Promise((resolve,reject)=&gt;&#123;&#125;)</span><br><span class="line">console.log(promise)//pending</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;resolve(&#x27;hello world&#x27;)&#125;).then(val=&gt;console.log(val))//resolve可以改变promise的状态，并且可以通过.then来拿到改变以后的结果</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;reject(&#x27;bad code&#x27;)&#125;).then(err=&gt;console.log(err))//状态时rejected，返回的结果bad code</span><br></pre></td></tr></table></figure>

<p>要想拿到使用reject改变以后的promise里面的值，除了使用.then方法以外同时可以使用catch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ew Promise((resolve,reject)=&gt;&#123;reject(&#x27;bad code&#x27;)&#125;).catch(fucntion(err)=&gt;console.log(err))</span><br></pre></td></tr></table></figure>

<p>除了.catch.then还有.finally方法，只有再promise状态被改变了以后才会触发finally函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;reject(&#x27;bad code&#x27;)&#125;).then(err=&gt;console.log(err).finally(()=&gt;console.log(&#x27;promise状态变更&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<p>把嵌套的回调函数改为链式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function counter(x,y,wait)</span><br><span class="line">&#123;</span><br><span class="line">return new Promise(function(resolve,reject)&#123;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">resolve(x+y)</span><br><span class="line">&#125;,wait)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">counter(1,2,1000).then(val=&gt;counter(val,1,1000)).then(num=&gt;console.log(num))</span><br></pre></td></tr></table></figure>

<p><strong>Promise的方法</strong></p>
<p>Promise.resolve(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(2).then(2)((val)=&gt;&#123;</span><br><span class="line">console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回的是一个状态为fulfilled的Promise对象并且有一个返回值为2</p>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">resolve(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.reject(n)方法返回一个带有拒绝原因的Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&#123;message:&quot;错误原因&quot;&#125;).catch((err)=&gt;console.log(err))</span><br></pre></td></tr></table></figure>

<p>Promise.all()方法接受一个promise的iterable类型，（Array，Map，Set都属于ES6的iterable类型），返回一个promise实例</p>
<p>只有再所有的promise状态都发生了变化以后才会拿到结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise1=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">const promise2=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">const promise3=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">const promise4=new Promise((resolve)=&gt;setTimeout(()=&gt;&#123;resolve(&#x27;123&#x27;)&#125;,2000))</span><br><span class="line">Promise.all(promise1,promise2,promise3,promise4).then((val)=&gt;console.log(val))</span><br><span class="line">---</span><br><span class="line">两秒以后输出</span><br><span class="line">123 123 123 123</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/Promise/" data-id="cl4o61a1o0001vkfo8bsfen5c" data-title="Promise" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-箭头函数和方法扩展" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T07:09:54.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/">箭头函数和方法扩展</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>传统函数声明</p>
<p>声明式：function fn(){}</p>
<p>表达式： var fn &#x3D; function(){}</p>
<p>箭头函数</p>
<p>var fn &#x3D; ()&#x3D;&gt;{}</p>
<p>如果参数只有一个参数只有一个可以省略（）</p>
<p>如果函数体只有一句return加表达式的话{}和return可以省略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn = v =&gt; v+1</span><br></pre></td></tr></table></figure>

<p>如果返回值并不是表达式的话可以使用（）来包裹起来同时可以省略return</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn  = v =&gt;(&#123;obj:v&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>箭头函数与普通函数的区别</strong></p>
<ol>
<li><p>箭头函数是没有this的，它的this是从作用域链上一层继承来的，同时也无法通过call和apply来改变this的指向</p>
</li>
<li><p>不能作为构造函数，没有protorypep属性</p>
</li>
<li><p>没有arguments对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3)</span><br><span class="line">---</span><br><span class="line">Arguments(3)&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">var foo = () =&gt;&#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3)</span><br><span class="line">---</span><br><span class="line">报错</span><br></pre></td></tr></table></figure>

<p>想要获取箭头函数的参数列表可以使用…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = (...arguments) =&gt;&#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3)</span><br><span class="line">---</span><br><span class="line">(3)&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>不能使用yield命令，所以箭头函数不能作为Generator函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//generator函数</span><br><span class="line">function *fn()&#123;</span><br><span class="line">yield 1;</span><br><span class="line">yield 2;</span><br><span class="line">return 3</span><br><span class="line">&#125;</span><br><span class="line">var f = fn()</span><br><span class="line">console.log(f)</span><br><span class="line">console.log(f.next())</span><br><span class="line">console.log(f.next())</span><br><span class="line">console.log(f.next())</span><br><span class="line">console.log(f.next())</span><br><span class="line">---</span><br><span class="line">fn&#123;...&#125;</span><br><span class="line">&#123;value:1,done:false&#125;</span><br><span class="line">&#123;value:2,done:false&#125;</span><br><span class="line">&#123;value:3,done:true&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>实际应用</strong></p>
<p>在函数内部想要拿到外部实例的时候可以使用箭头函数，这样函数体中的this就直接指向了外部实例</p>
<p>setTimeout，setInterval</p>
<p><strong>函数扩展方法</strong></p>
<ol>
<li><p>给函数的参数指定默认值，es5</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn (x,y)&#123;</span><br><span class="line">//如果y存在，那么就取y，如果y不存在，那么就y=1</span><br><span class="line">y = y||1</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn (x,y=1)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn (&#123;x,y=1&#125;)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;X:1&#125;)</span><br><span class="line">//先解构，然后再赋一个默认值</span><br></pre></td></tr></table></figure>


</li>
<li><p>通过rest参数获取函数的多余参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn (x,...y)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,3,4)</span><br><span class="line">---</span><br><span class="line">1</span><br><span class="line">2,3,4</span><br></pre></td></tr></table></figure>

<p>…y称为rest参数，是所有未被定义的实参的参数数组集合，也一样可以解构赋值。如果参数是对象的话那么就是所有未被定义的属性所形成的一个新的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn(&#123;x,...y&#125;)&#123;</span><br><span class="line">console.log(x)</span><br><span class="line">console.log(y)</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;x:1,a:2,b:3&#125;)</span><br><span class="line">---</span><br><span class="line">1</span><br><span class="line">&#123;a:2,b:3&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/" data-id="cl4o61a1s0004vkfo1pdz6779" data-title="箭头函数和方法扩展" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Iterator和for-of循环" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T06:18:05.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/">Iterator和for...of循环</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Iterator概念</p>
<p>Iterator接口的目的就是为所有的数据结构提供一种统一的访问机制，即for of循环从而完成遍历的操作。当使用for…of循环时，该循环会自动调用Iterator的接口。</p>
<p>for…of循环的遍历过程</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置，因而遍历器本质上就是一个指针对象</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的next方法，可以将指针指向数据结构的第二个成员</li>
<li>不断调用指针对象，直到它指向数据结构的最后结束位置</li>
</ol>
<p>每一次调用next方法返回一个包含value和done两个属性的对象</p>
<p>其中value是当前成员的值，done属性是一个布尔值，表示遍历是否结束</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>(arr)</span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">//value:&#x27;1&#x27;,done:false</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">//value:&#x27;2&#x27;,done:false</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">//value:undefined,done:true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> nextIndex&lt;arr.<span class="property">length</span>?&#123;</span><br><span class="line">         <span class="attr">value</span>:arr[nextIndex++],<span class="attr">done</span>:<span class="literal">false</span></span><br><span class="line">     &#125;:&#123;</span><br><span class="line">         <span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Iterator接口时部署在Symbol.iterator属性</strong></p>
<p>如果一个数据结构具有Symbol.iterator属性，那么这个数据结构就是可便利的。</p>
<p>Symbol.iterator属性本身是一种函数，就是当前数据结构的遍历器默认生成的一个函数，执行这个函数就会放回一个遍历器对象，（该对象的根本特征就是会具有next方法，每一次调用next()，都会返回一个代表当i请安成员的信息对象,这个对象具有value和done两个属性）</p>
<p>对象的Symbol.iterator属性指向了该对象的默认遍历器方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">[Symbol.iterator] : function()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">next:function()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">value:1,</span><br><span class="line">done:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果要使用特殊的属性名，不能采用 . 的方式来操作</em></p>
<p><em>需要使用另一种方式：语法：对象[“属性名”] &#x3D; 属性值</em></p>
<p><em>读取时也需要采用这种方式</em></p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">[Symbol.iterator] : function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var it = arr[Symbol.iterator]()</span><br></pre></td></tr></table></figure>

<p><strong>原生具备iterator接口的数据结构</strong></p>
<p>Map,Set,Array,String,函数的arguments对象(伪数组)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;1&#x27;,&#x27;2&#x27;]</span><br><span class="line">var it = arr[Symbol.iterator]()</span><br><span class="line">it.next()</span><br><span class="line">//value:&#x27;1&#x27;,done:false</span><br><span class="line">it.next()</span><br><span class="line">//value:&#x27;2&#x27;,done:false</span><br><span class="line">it.next()</span><br><span class="line">//value:undefined,done:true</span><br></pre></td></tr></table></figure>

<p>对于原生部署了iterator的数据结构来说可以直接使用forof循环,但是如果没有iterator的接口的话(主要是数组),那么就要自己在[Symbol.iterator]上部署接口,这样才会被for…of循环</p>
<p>对象不具备iterator接口的原因是对象哪一个属性先遍历,哪一个属性后遍历时不确定的,需要开发者手动部署</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">data</span>:[<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>],</span><br><span class="line">[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">next</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;self.<span class="property">data</span>.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;&#123;<span class="attr">value</span>:self.<span class="property">data</span>[index++],<span class="attr">done</span>:<span class="literal">false</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/21/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/" data-id="cl4o61a1l0000vkfog8u7c8tz" data-title="Iterator和for...of循环" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/Map/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T12:02:16.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/Map/">Map</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Map是新的应用类型的字符串，类似于对象，但是键的范围但不限于字符串，各种类型的值包括对象类型的值都可以当作键</p>
<p>Object提供了‘字符串—值’的对应</p>
<p>Map提供了‘值—值’的对应，是一种更加完美的键值对的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p:&#x27;hello world&#x27;&#125;</span><br><span class="line">m.set(o,&#x27;content&#x27;)</span><br><span class="line">m.get(o)//&quot;content&quot;</span><br><span class="line">m.has(o)//true</span><br><span class="line">m.delete(o)//true</span><br><span class="line">m.has(o)//false</span><br></pre></td></tr></table></figure>

<p><strong>证明Map()是引用数据类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">console.log(map instance Map)//true</span><br><span class="line">console.log(Object.prototype.toString.call(map))//[object Map]</span><br></pre></td></tr></table></figure>

<p><em>console.log(Object.prototype.toString.call(map))使用原型链顶端的toString()方法的原因是因为数组和对象对toString()的方法进行了改写</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">toString:function()&#123;</span><br><span class="line">return &#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.toString()</span><br><span class="line">//这样就会覆盖.toString方法从而导致问题</span><br></pre></td></tr></table></figure>

<p><strong>Map可以接受数组作为参数，在Map构造函数中接受的数组必须是一个个表示键值对的数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let m =new Map([ [&#123;&#x27;name&#x27;:&#x27;z3&#x27;&#125;,1],[age,18] ])</span><br></pre></td></tr></table></figure>

<p>Map的存储特点是把对象作为键名的时候传输的是地址，所以下列中的两个{x:1}虽然形式相同但是实际的值不同，（存储在堆内存中的不同位置）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map([</span><br><span class="line">&#123;x:1&#125;,&#x27;abc&#x27;</span><br><span class="line">])</span><br><span class="line">console.log(m.get(&#123;x:1&#125;))</span><br><span class="line">//undefined</span><br><span class="line">//这里存进去的&#123;x:1&#125;其实是这个对象在堆内存中的地址</span><br><span class="line">let obj = &#123;x:1&#125;</span><br><span class="line">let m = new Map([</span><br><span class="line">obj,&#x27;abc&#x27;</span><br><span class="line">])</span><br><span class="line">console.log(m.get(obj))</span><br><span class="line">//abc</span><br></pre></td></tr></table></figure>

<p>Map可以接受数组作为参数，在Map构造函数中接受的数组必须是一个个表示键值对的数组的本质</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let m =new Map([ [&#123;&#x27;name&#x27;:&#x27;z3&#x27;&#125;,1],[age,18] ])</span><br><span class="line">//内部机制</span><br><span class="line">items.forEach(</span><br><span class="line">//([key,value],index)=&gt;m.set(key,value)</span><br><span class="line">([key,value])=&gt;m.set(key,value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> <strong>Map自带的方法</strong></p>
<p>m.keys()</p>
<p>m.values()</p>
<p>m.entries()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map([[&#x27;a&#x27;,&#x27;b&#x27;],[&#x27;c&#x27;,&#x27;d&#x27;]])</span><br><span class="line">m.set(&#x27;e&#x27;,10)</span><br><span class="line">console.log(m.size)</span><br><span class="line">console.log(m.keys())//输出所有键</span><br><span class="line">console.log(m.values())//输出所有值</span><br><span class="line">console.log(m.entries())//输出所有对应关系</span><br><span class="line">---</span><br><span class="line">3</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;&#125;</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;d&#x27;, 10&#125;</span><br><span class="line">&#123;&#x27;a&#x27; =&gt; &#x27;b&#x27;, &#x27;c&#x27; =&gt; &#x27;d&#x27;, &#x27;e&#x27; =&gt; 10&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Map参数的扩展</strong></em></p>
<p><em>任何具有Iterator接口，且每一个成员都是一个双元素的数组的数据结构，都可以当作Map构造函数的参数，</em></p>
<p><em>所以set和map也都可以作为Map构造函数的初始值，只要是每一个成员都是一个双元素的数组。</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/Map/" data-id="cl4mp48je0000c0fo7x8yctqv" data-title="Map" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Set" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/Set/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T11:00:21.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/Set/">Set</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Set是新的引用类型的数据解构，类似于数组，但是每一个成员都是唯一的，没有重复的值</p>
<p>Set本身是一个构造函数，用来生成Set数据结构</p>
<p>Set函数可以接受一个数组作为参数，用于初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3,4,1])</span><br><span class="line">console.log(set)</span><br><span class="line">---</span><br><span class="line">Set(4)&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Set可以转化为数组</strong>（通过…或者Array.from()），原因是应为Set数据结构支持for of循环（内部部署了iterator接口）</p>
<p>可以快速实现数组去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3,4,1])</span><br><span class="line">Array.from(set)</span><br><span class="line">[...set]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Set数据内部判断值的机制</strong>所使用的算法类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），但是如果是多个NaN的话那么Set会返回一个NaN，因为在Set内部两个NaN是全等的，但是对于精确相等运算符来说两个NaN是不全等的。</p>
<p><strong>Set实例的属性和方法</strong></p>
<p>set.add(1)：添加元素</p>
<p>set.has(1)：判断是否有这个属性</p>
<p>set.delete(2)：删除</p>
<p>set.forEach()：Set结构的实例和数组一样也是拥有forEach的方法，对每一个成员执行某种操作，没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let set = [1,4,3]</span><br><span class="line">set.forEach((value，index)=&gt;console.log(index+&#x27;:&#x27;+value))</span><br><span class="line">---</span><br><span class="line">1:1</span><br><span class="line">4:4</span><br><span class="line">3:3</span><br></pre></td></tr></table></figure>

<p><em>对于set.forEach来说是没有索引这个概念的，所以</em>：左右都一样</p>
<p>Set可以实现数组之间的集合操作</p>
<p>并集：let set &#x3D; new Set([…a,…b])</p>
<p>交集：let set &#x3D; new Set([…a].filter(x&#x3D;&gt;b.has(x)))</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/Set/" data-id="cl4mp48jh0001c0fogjb78920" data-title="Set" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Symbol" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/Symbol/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T08:45:14.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/Symbol/">Symbol</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> Symbol是es6新增的一种基本数据类型，只要是用于保证每一个对象属性的名字都是独一无二的</p>
<p>symbol函数可以接受一个字符串作为参数，表示对symbol实例的描述，主要是为了在控制台输出，或者转化为字符串时，比较容易曲风。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1=Symbol(&#x27;1&#x27;)</span><br><span class="line">let s2=Symbol(&#x27;2&#x27;)</span><br><span class="line">s1</span><br><span class="line">s2</span><br></pre></td></tr></table></figure>

<p>Symbol参数是一个对象时，就会调用该对象的toString方法，将其转化为字符串，然后才生成一个Symbol值</p>
<p>Symbol函数的参数只是对当前Symbol值的描述，所以相同参数的Symbol函数的返回值是不一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;</span><br><span class="line">let b = &#123;b:1&#125;</span><br><span class="line">let s1=Symbol(a)</span><br><span class="line">let s2=Symbol(b)</span><br><span class="line">let o = &#123;&#125;</span><br><span class="line">o[s1]=1</span><br><span class="line">o[s2]=2</span><br><span class="line">//如果不使用symbol的话，那么obja和objb在转换成字符串以后都是相同的，所以属性值会覆盖，但是使用symbol了以后就不会</span><br></pre></td></tr></table></figure>

<p>对象的Symbol.iterator属性</p>
<p>这是指向对象的默认遍历器方法,对象进行for of循环时，会调用Symbol.iretator方法返回该对象的默认遍历器</p>
<p>Object.getOwnPropertySymbols方法</p>
<p>可以获得只当对象的所有Symbol属性名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;</span><br><span class="line">let b = &#123;b:1&#125;</span><br><span class="line">let s1=Symbol(a)</span><br><span class="line">let s2=Symbol(b)</span><br><span class="line">let o = &#123;&#125;</span><br><span class="line">o[s1]=1</span><br><span class="line">o[s2]=2</span><br><span class="line">const objectStmbol=Object.getOwnPropertySymbols(o)</span><br><span class="line">---</span><br><span class="line">Symbol(s1) Symbol(s2)</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<p>私有属性，用symbol定义的属性名是在外界访问不到的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let private = Symbol(&#x27;private&#x27;)</span><br><span class="line">var obj = &#123;</span><br><span class="line">[private]:&#x27;私有属性&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = 1</span><br><span class="line">const two = 2</span><br><span class="line">//使用symbol的话就可以支持一样的变量名</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/Symbol/" data-id="cl4mp48jj0002c0fohnt8go7x" data-title="Symbol" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-解构赋值" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T08:01:00.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/">解构赋值</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> <strong>数组解构赋值</strong></p>
<p>按照一定模式，对数组中提取值，对变量进行赋值，这被称为解构赋值</p>
<p>方便地将一组参数与变量名对应起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c]=[1,2,3]</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>

<p><strong>模式匹配</strong></p>
<p>只要等号两边地模式相同，左边地变量就会被赋予对应的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [foo,[[bar],baz]]=[1,[[2],3]]</span><br><span class="line">let [,,third]=[1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>对象的解构赋值</strong></p>
<p>允许使用自变量的语法将对象的属性赋给变量，可以取得继承的属性</p>
<p>变量名必须属性名相同才能取到正确的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;bar&#125; = &#123;bar:&#x27;123&#x27;,foo:&#x27;456&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>同时也可以使用 :变量名的写法进行重命名,这样真正被赋值的就是后者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123;bar:baz&#125; = &#123;bar:&#x27;123&#x27;,foo:&#x27;456&#x27;&#125;</span><br><span class="line">console.log(baz)</span><br><span class="line">---</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>对象的解构赋值可以和数组解构赋值一起使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">p:[&#x27;1&#x27;,&#123;</span><br><span class="line">y:&#x27;2&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br><span class="line">let &#123;p:[x,&#123;y&#125;]&#125;=obj</span><br></pre></td></tr></table></figure>

<p>对象的解构可以设置默认值,默认值生效的条件是对象的属性值严格等于undefined</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x=3&#125;=&#123;&#125;</span><br><span class="line">---</span><br><span class="line">x=3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x:y=3&#125;=&#123;x:5&#125;</span><br><span class="line">---</span><br><span class="line">y=5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x=3&#125;=&#123;x:undefined&#125;</span><br><span class="line">---</span><br><span class="line">x=3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x=3&#125;=&#123;x:null&#125;</span><br><span class="line">---</span><br><span class="line">x=null</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/" data-id="cl4mp48jl0004c0fo4ghydm7u" data-title="解构赋值" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-let-const-var暂时性死区" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/let-const-var%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T07:34:34.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/let-const-var%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/">let,const var暂时性死区</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>let，const声明的变量不会发生变量提升，但var声明的变量就可以，变量在声明前就可以使用，值为undefined，原因是因为预编译的时候就已经把变量存入变量对象中。</p>
<p><strong>暂时性死区</strong></p>
<p>在代码块内使用let命令声明变量之前，变量时不能被使用的，在语法上称为暂时性死区TDZ</p>
<p>let是不能被重复声明的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function(b)&#123;</span><br><span class="line">let b</span><br><span class="line">&#125;</span><br><span class="line">//报错</span><br></pre></td></tr></table></figure>



<p><strong>块级作用域</strong></p>
<p>允许块级作用域的任意嵌套，但是每一层都是一个单独的作用域，每一层中的数据不互通。</p>
<p>应用场景：</p>
<p>内层变量可能会覆盖外面的变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var date= new Date()</span><br><span class="line">function f()&#123;</span><br><span class="line">//var date</span><br><span class="line">console.log(date)</span><br><span class="line">if(true)&#123;</span><br><span class="line">var date=&#x27;1&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>循环内部的计数变量泄露为全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4]</span><br><span class="line">for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">console.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">console.log(i)</span><br><span class="line">---</span><br><span class="line">1 2 3 4 4</span><br></pre></td></tr></table></figure>



<p><strong>const特殊之处</strong></p>
<p>const一旦声明就不能被改变，并且必须要给一个初始值。</p>
<p>但如果const后面是一个引用数据类型，那么地址是在栈里面不能够改变，但是真正的数据是存放在堆里面的，也就可以改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj=&#123;&#125;</span><br><span class="line">obj.name=&#x27;123&#x27;</span><br></pre></td></tr></table></figure>



<p><em>for循环内部变量 i 和循环变量 i 不在同一个作用域中。</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/let-const-var%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/" data-id="cl4mp48jj0003c0fobzjv39im" data-title="let,const var暂时性死区" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/21/class/">class</a>
          </li>
        
          <li>
            <a href="/2022/06/21/async%E5%92%8Cawait/">async和await</a>
          </li>
        
          <li>
            <a href="/2022/06/21/Promise/">Promise</a>
          </li>
        
          <li>
            <a href="/2022/06/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/">箭头函数和方法扩展</a>
          </li>
        
          <li>
            <a href="/2022/06/21/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/">Iterator和for...of循环</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>